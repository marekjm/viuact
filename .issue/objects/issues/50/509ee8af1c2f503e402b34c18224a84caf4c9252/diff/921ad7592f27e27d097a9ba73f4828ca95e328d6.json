[{"action": "open", "author": {"author.email": "marekjm@ozro.pw", "author.name": "Marek Marecki"}, "timestamp": 1542911181.999022}, {"action": "set-message", "params": {"text": "Create a module system\n\nUse Rust's model for layout.\nSkip the `use x::y;` syntax. In Viuact the modules cannot be used and\nmust always use the full path.\n\n----------------\n\nPROPOSED SYNTAX\n\nInline module\n\n    (module Example (\n        (let fn (x) (\n            (print (x))\n        ))\n    ))\n\nInline modules are defined inside the file, and are immediately imported.\nThis immediate import behaviour will be changed when interface files are\nemitted by the compiler.\n\n----\n\nModule in a separate file\n\n    (module Example)\n\nThe compiler must look for either a file named `Example.lisp`, or a\ndirectory named `Example` with a file named `mod.lisp` inside.\nThe module is not immediately imported as there is no way to signal the\ninterface between compiler runs.\n\n----\n\nInterface files\n\nFiles with the .i extension, describing just the functions exported by a\nmodule. The syntax is like this:\n\n    (module Example (\n        (declare let fn (x))\n    ))\n\nThe only difference between the interface file and implementation file\nis the fact that functions do not have bodies, and the `declare` keyword\nis prepended to them.\n\n----\n\nImporting a module\n\n    (import Example.Nested)\n\nImporting a module makes the functions it exports available in current\nscope."}, "author": {"author.email": "marekjm@ozro.pw", "author.name": "Marek Marecki"}, "timestamp": 1542911181.999032}, {"action": "push-tags", "params": {"tags": []}, "author": {"author.email": "marekjm@ozro.pw", "author.name": "Marek Marecki"}, "timestamp": 1542911181.999034}, {"action": "push-milestones", "params": {"milestones": []}, "author": {"author.email": "marekjm@ozro.pw", "author.name": "Marek Marecki"}, "timestamp": 1542911181.999037}]