
                        VIUACT COMPILER DEVELOPMENT LOG

--------------------------------------------------------------------------------

This file describes the history of, and events that occured during, the Viuact
compiler development.

On every day when something related to the project is done, a relevant entry is
made in this file. An example entry looks like this:

>   TITLE OF THE ENTRY
>   (2018-12-22 16:29)
>
>   Contents of the entry.

Contents of each entry may be short (e.g. "A new issue was added."), or long
(e.g. a description of how a problem was resolved, or summary of a discussion).

--------------------------------------------------------------------------------

IMPLEMENT VECTOR CTOR
(2019-01-10 06:44)

The vector data type provided by Viua VM is exposed to Viuact.

Implementing functions to manipulate structs (like push() and at()) forced me to
attempt implementing automatic pointer dereference. Automatic pointer
dereferencing is required if I want to avoid adding the pointer dereference
operator. However, manual pointer management may need to be added anyway if I do
not manage to make the compiler "smart" enough to produce correct pointer
dereferencing code reliably and consistently.

--------------------------------------------------------------------------------

CREATE A USER MANUAL
(2019-01-09 19:15)

A kind of a "user manual" is available in docs directory. It describes how to
compile a simple "Hello World!" program, what options does the compiler provide,
and a stub description of the compilation process.

--------------------------------------------------------------------------------

IMPLEMENT DEFERRED CALLS
(2019-01-09 06:49)

Deferred calls may be scheduled in Viuact. This is a feature of Viua VM
(inspired by Golang's "go" feature) that is incredibly useful in writing correct
resource management code as it allows scheduling clean-up code to be run at the
end of the function's life near the place where the resource is acquired. It
approaches the power of RAII (as known from C++) if properly used.

--------------------------------------------------------------------------------

FIXES IN VIUA VM
(2019-01-08 19:39)

I needed to fix two bugs in Viua VM.

The first one was inside the static analyser; the SA continued analysing a
control flow path after encountering a tail call which is clearly incorrect as a
tail call replaces the current frame of execution rendering any analysis *after*
a tail call pointless since at runtime the control flow path analysed would
cease to exist.

The second one was inside the linker. It was calculating symbol offsets
incorrectly, thus trying to load all modules specified for static linking on the
command line at the same address. This bug was triggered only when more than one
module was specified to be linked during a single run; the following invocation
produced the correct result:

    $ viua-asm --verbose foo.asm bar.out

...but a one like this would produce an error informing the user that functions
A and B (coming from bar.out and baz.out) were loaded at the same address:

    $ viua-asm --verbose foo.asm bar.out baz.out

These bugs were easy to find and fix, and were discovered due to Viuact compiler
stress-testing Viua's tooling.

--------------------------------------------------------------------------------

DUMP INTERMEDIATE FORM REPRESENTATIONS TO DISK
(2019-01-07 21:38)

The compiler is able to dump a representation of the in-memory structures used
to represent source program. Available "dump points" are:

- after lexical analysis
- after syntactical analysis

Since the compiler does very little semantic analysis (it is pretty simple) the
representation that is used during assembly code emission is not dumpable as it
would not be useful - the assembly output is actually a good representation of
what the final intermediate form looks like.

--------------------------------------------------------------------------------

IMPLEMENT TAIL CALLS
(2019-01-06 22:03)

It is now possible to instruct the compiler that a call should be a tail call.
To do so, you prepend the "tailcall" keyword before the call (similarly to how
actors are spawned - with the "actor" keyword):

    (tailcall fn 42)

This will emit a tail call instead of a normal call.

--------------------------------------------------------------------------------

IMPLEMENT STRUCT FIELD ACCESS
(2019-01-06 17:02)

It is now possible to refer to struct fields in expressions, for example:

    (print (+ some_struct.some_field 1))

This means that struct mutation is now avalable:

    (:= x.some.field (+ x.some.field 1))

What is left: concurrency, error handling, vectors, and FFI libraries.

--------------------------------------------------------------------------------

IMPLEMENT NESTED STRUCT FIELD UPDATES
(2019-01-05 13:09)

It is now possible to update values of fields in structs nested structs. This
allows the creation of more complex data structers. Fields of nested structs are
specified after a operator dot:

    (:= a_struct.inner_struct.more_inner_struct.field_name 42)

The implicit requirement is that all but the last name point to a struct typed
value.

--------------------------------------------------------------------------------

IMPLEMENT SIMPLE STRUCT FIELD UPDATES
(2019-01-04 20:28)

It is now possible to update values of fields in structs. A special-purpose
struct field update operator is used to do this:

    (:= a_struct.field_name 42)

This will update the value of the field named `field_name` of struct named
`a_struct` to be integer 42.

--------------------------------------------------------------------------------

FIX USELESS COPIES IN PRINTS
(2019-01-02 22:01)

The compiler no longer emits a copy instruction for calls to print() where the
argument is a simple name. In other words, such code:

    (print x)

is compiled to:

    print %x local

instead of:

    copy %y local %x local
    print %y local

This means the emitted code is more performant (avoiding unnecessary copies) and
correct (for the same reason).

--------------------------------------------------------------------------------

FIX BRANCH NAME GENERATION
(2019-01-02 21:53)

I fixed a bug that caused infinite loops in code with if expressions. If
branches that had the same body were assigned the same ID, which caused jumps to
be calculated wrongly and under specific conditions caused infinite loops to be
generated.

Viua VM assembler must be fixed to disallow reusing names of branches in the
same code block.

--------------------------------------------------------------------------------

BASIC SUPPORT DYNAMIC IMPORTS ON VIUA VM SIDE
(2018-12-30 10:35)

Information about dynamic imports is now stored inside bytecode modules (both
linkable and executable). It is reported by the loader to the kernel during
program startup; the kernel then invokes the module loading routine for the
requested module.

This means that manually setting the VIUAPRELINK environment variable is no
longer necessary.

One limitation of current implementation is that dynamic imports of dynamic
imports are resolved at compile time instead of at run time. This means that
even if there is a newer version of a module that is dynamically imported its
dependencies will be imported as if the older version was run.

--------------------------------------------------------------------------------

CHANGES IN MODULE IMPLEMENTATION ON VIUA VM SIDE
(2018-12-28 14:56)

Viua VM was using a ".vlib" extension for files containing modules (linkable
bytecode). Now, to accommodate Viuact, the extension was changed to ".module".
Commit 89889b5acbc79f1d4d5c023669f775fdef539f30 introduces the change.

Static imports work on Viua VM side. A module (or an executable) can request
that another module be statically linked to it by using the ".import:"
directive with "static" attribute:

    .import: [[static]] A_module

This will make the linker look for "A_module.module" file, and statically link
it to the current "main" module.

There is also basic support for dynamic imports, but it is not finished yet.
You can specify a dynamic link using the ".import:" directive with "dynamic"
attribute...

    .import: [[dynamic]] A_module

...and it will pass the verification stage, but there will be nothing in the
assembled module that will tell the runtime linker to look for a module and
link it. You will have to use the "VIUAPRELINK" environment variable to
instruct the VM to link required modules before invoking the main function of
the loaded executable:

    $ VIUAPRELINK=A_module viua-vm ./a.out

--------------------------------------------------------------------------------

FIRST ENTRY
(2018-12-22 16:31)

The log file was established. It will be maintained as a log of what happened
during Viuact development, when, and why. I decided to start writing it after
a discussion with Krzysztof - we came to the conclusion (which was put forward
by Krzysztof) that *whatever* is done that has its root cause in the Viuact
project should be documented. This way we will be able to put the entire
history of the project and its supporting work inside the final "paper" (or
whatever it will be called).

--------------------------------------------------------------------------------

vim:textwidth=80
