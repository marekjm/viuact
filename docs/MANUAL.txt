                             VIUACT COMPILER MANUAL
--------------------------------------------------------------------------------

Viuact is an almost purely expression-based language, that has features designed
for massive concurrency based on the actor model. It has a Lisp-like syntax and
compiles down to Viua VM assembly.

Viuact's most notable features include:

- actors
- module system
- nested functions
- immutable closures

Actors in Viuact are internally sequential (meaning that every actor executes a
sequential stream of expressions), isolated processes that communicate through
message passing.

Message passing in Viuact is direct (it happens directly between two processes
without any intermediate channels), asynchronous (a message is sent and the
control immediately returns to the running process without receiving an
acknowledgement from the recipient), and comes without any guarantees (meaning
that a reliability-ensuring protocol must be implemented on top of it in "user
space").

In Viuact names are dynamically typed (meaning that a name may be rebound to
values of different types during a single function's execution), and values are
statically typed (every value may be assigned a type during compile time). After
a name is rebound it cannot be used to access the value it held previously, but
the references that appeared before the rebinding all point to the old value (a
prior art example is either OCaml or Rust).

Viuact supplies the programmer with a set of few basic datatypes, on top of
which the programmer may built their custom data structures:

- integer: signed, usually 64 bit wide, but otherwise platform-defined
- float: floating point value, platform-defined but usually a C double
- boolean: boolean type representing either true or false value
- string: a sequence of Unicode codepoints encoded using UTF-8
- struct: a key-value mapping
- vector: a dynamically-sized collection of values, indexed by integers

A special data type is "pid". Pids represent actor IDs and are used as their
addresses during message passing. An actor must have a Pid of another actor to
send it a message.

--------------------------------------------------------------------------------
USAGE

To compile a canonical "Hello World!" example...

    (let main () (
        (print "Hello World!")
        0
    ))

...you would have to execute the following shell commands (assuming you stored
the above exapmle source code in the `hello_world.lisp` file):

    $ viuact-cc --mode exec hello_world.lisp
    $ viuact-opt build/_default/hello_world.asm

The resulting executable bytecode is stored in "build/_default/hello_world.bc"
file. You can run it using Viua VM kernel:

    $ viua-vm build/_default/hello_world.bc
    Hello World!

The "hello_world.bc" (the "bc" extension is from "bytecode") file name is
derived from the name of the main source file. Inside the build directory (named
"build/_default") you will find several other files:

- hello_world.asm: compiled, assembly language version of the original Viuact
  source of the example program
- hello_world.d: a "dependency specification" for the "hello_world" program;
  this is the file that is read by viuact-opt to automatically discover what it
  needs to link to the main program

After the compilation, you will have four files in total:

- hello_world.lisp
- build/_default/hello_world.asm
- build/_default/hello_world.d
- build/_default/hello_world.bc

--------------------------------------------------------------------------------
COMPILATION OPTIONS

The compiler has no options except "--mode". The assembler-linker driver has
absolutely no options.

Synopsis for the compiler:

    $ viuact-cc --mode ( exec | module ) <file>.lisp

Synopsis for the assembler-linker driver:

    $ viuact-opt <file>.asm

You can affect the compiler and assembler-linker driver through environment
variables.

DEFAULT_OUTPUT_DIRECTORY

Specifies the output directory.

VIUAC_LIBRARY_PATH

Specifies where the compiler and assembler-linker driver should look for
bytecode modules and module interface files. Paths are separated using the ":"
character (as specified by convention used on *NIX systems).

VIUA_ASM_PATH

Specifies the path to the Viua VM assembler executable.

VIUAC_VERBOSE

Enables verbose output if passed as "true" or "yes".

VIUAC_DEBUGGING

Enables debugging output if passed as "true" or "yes".

VIUAC_INFO

Enables informative output if passed as "true" or "yes".

VIUAC_DUMP_INTERMEDIATE

Instructs the compiler to dump intermediate representation images to the output
directory. This produces at most two files:

- `<file>.tokens`: a JSON representation of the token list as seen by the
  compiler
- `<file>.expressions`: a JSON representation of the expression tree as produced
  by the parser

These images are *strictly write-only* from the compiler's point of view. They
may only be output, not consumed by it and are only intended as a debugging aid.

This will produce the ".tokens" file:

    $ VIUAC_DUMP_INTERMEDIATE=tokens viuact-cc hello_world.lisp

This will produce both the ".tokens" and the ".expressions" file:

    $ VIUAC_DUMP_INTERMEDIATE=tokens,exprs viuact-cc hello_world.lisp

--------------------------------------------------------------------------------
COMPILATION PROCESS EXPLAINED

Compilation from Viuact to executable bytecode is split into two stages:

- compilation
- assembly and linkage

Why are assembly and linkage merged into a single stage?

Assembly (turning a sequence of assembly language instructions into a
machine-readable bytecode) and linkage (linking two or more bytecode modules
together while resolving and possibly relocating symbols) are usually two
separate stages Viuact merges them. This is entirely due to the specifics of the
tooling supplied by Viua VM.

To compile a Viuact program two programs are used:

- `viuact-cc.py`: the compiler
- `viuact-opt.py`: the assembler-linker that drives the tooling provided by Viua
  VM

--------------------------------------------------------------------------------

vim:textwidth=80
